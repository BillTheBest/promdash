angular.module("Prometheus.directives").directive('inlineFrame', ["$sce", "VariableInterpolator", "GraphiteTimeConverter", "WidgetHeightCalculator", function($sce, VariableInterpolator, GraphiteTimeConverter, WidgetHeightCalculator) {
  var FRAME_CONTAINER_PADDING = 10;
  var FRAME_BACKGROUND_COLOR = '%23191919';
  return {
    scope: {
      frame: "=frameSettings",
      aspectRatio: "=",
      index: "=",
      vars: "="
    },
    restrict: "AE",
    templateUrl: "<%= asset_path('frame_template.html') %>",
    link: function(scope, element, attrs) {
      // Appended to frame source URL to trigger refresh.
      scope.refreshCounter = 0;
      function frameHeight() {
        return WidgetHeightCalculator(element.find(".js_widget_wrapper")[0], scope.aspectRatio);
      }

      // In order for zoom-out to work correctly on dashboards with iframes,
      // the iframe needs to be completely reconstructed on each refresh.
      // Modifying an iframe's src attribute, as in the previous implementation,
      // changes the browser's history. This interrupts a user's attempt to zoom
      // out as it takes an additional history.back() execution to traverse the
      // history state added by modifying an iframe's src.
      // http://khaidoan.wikidot.com/iframe-and-browser-history
      scope.refreshFrame = function() {
        var url = VariableInterpolator(scope.frame.url, scope.vars);
        var trustedURL = $sce.trustAsResourceUrl(buildFrameURL(url));
        var frame = element.find('.frame_container');
        frame.height(frameHeight());
        frame.html('<iframe src="'+ trustedURL +'" class="frame_iframe" marginwidth="0" scrolling="no"></iframe>');
      };

      var a = ['frame.url', 'frame.range', 'frame.endTime', 'refreshCounter', 'frame.graphite'];
      a.forEach(function(w) {
        scope.$watch(w, scope.refreshFrame);
      });
      ['refreshDashboard', 'redrawGraphs'].forEach(function(m) {
        scope.$on(m, scope.refreshFrame);
      });

      function buildFrameURL(url) {
        var parts = url.split('?'),
        var path = parts[0];
        var query = parts[1] ? parts[1].split('&') : [];

        if (scope.frame.graphite) {
          query = parseGraphiteQuery(query);
        }

        query.push('decache=' + scope.refreshCounter);
        query = query.map(function (component) {
          return component.split('=').map(encodeURIComponent).join('=');
        });

        return [path, query.join('&')].join('?');
      }

      function parseGraphiteQuery(query) {
        var fields = {};
        var targets = [];

        query.forEach(function(f) {
          var s = f.split('=');
          // If there are more than 1 target in the query string, they get overridden.
          // So we can't put them in the fields object.
          if (s[0] !== 'target') {
            fields[s.shift()] = s.join('=');
          } else {
            targets.push(f);
          }
        });

        var height = frameHeight();

        return [
          'height=' + height,
          'width=' + ((height / scope.aspectRatio) - FRAME_CONTAINER_PADDING),
          'from=' + GraphiteTimeConverter.graphiteFrom(scope.frame.range, scope.frame.endTime),
          'until=' + GraphiteTimeConverter.graphiteUntil(scope.frame.endTime),
          'bgcolor=' + FRAME_BACKGROUND_COLOR
        ].concat(targets);
      }
    }
  };
}]);
